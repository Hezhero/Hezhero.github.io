---
title: docker知识点
author: hzhero
date: 2023-03-20 19:20:00 +0800
categories: [运维, Docker]
tags: [docker]     # TAG names should always be lowercase
math: true
mermaid: true
render_with_liquid: false

[//]: # (pin: true)
---

<center><h1>docker知识点</h1></center>


# 一、基本概念
## 1、Docker架构

Docker 架构包括以下几个核心组件：

```
1. Docker 客户端 (Client): 用户与 Docker 交互的命令行工具或 API。
2. Docker 服务器 (Server): 负责管理镜像、容器、网络等资源的后台服务。
3. Docker 镜像 (Image): 是一个只读的模板，包含用于创建容器的文件系统和应用程序代码。
4. Docker 容器 (Container): 是 Docker 的基本执行单元，一个镜像可以创建多个容器，容器之间互相隔离，包括文件系统、网络、进程等资源。
5. Docker Registry (仓库): 存储 Docker 镜像的中央仓库，提供镜像的下载和上传服务。
6. Docker Compose: 是一个用于定义和运行多个容器的工具，简化了容器编排的复杂度。
7. Docker Swarm: 是 Docker 的集群管理工具，可以将多个 Docker 主机组成一个虚拟的 Docker 主机集群，提供负载均衡、容错等功能。
```

这些组件协同工作，构成了 Docker 强大的应用容器化解决方案。

## 2、Docker隔离原理

Docker 通过多种技术实现容器的隔离，包括：

```
1. 命名空间 (Namespace)：Docker 使用多种命名空间，如 mount、pid、net、ipc、uts 等，将容器的进程、网络、文件系统等资源与主机分离，使得容器拥有自己独立的运行环境。
2. 控制组 (Cgroups)：Docker 使用 Cgroups 控制组技术，限制容器内部进程使用的资源，如 CPU、内存、磁盘等。
3. 文件系统：Docker 使用 OverlayFS 技术，将容器的文件系统与主机分离，每个容器都有自己独立的文件系统，并可以使用 Docker 镜像中的文件系统层，实现镜像共享和快速启动。
4. 安全机制：Docker 使用安全机制，如 seccomp、AppArmor、SELinux 等，限制容器内部进程的系统调用和权限，防止容器被攻击和滥用。
5. 网络隔离：Docker 使用网络隔离技术，将容器的网络与主机分离，每个容器都有自己独立的网络命名空间和 IP 地址，实现容器之间的隔离和互通。
```

通过这些技术的组合，Docker 实现了容器之间的隔离，使得容器可以在相互独立的环境中运行，同时也保障了容器的安全和稳定性。

## 3、Docker安装
### 1、移除旧版本

```
sudo yum remove docker*
```

### 2、设置docker yum源

```
sudo yum install -y yum-utils

sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

### 3、安装最新的docker image

```
sudo yum install docker-ce docker-ce-cli containerd.io
```

### 4、安装指定版本的docker image

#### 1、在线安装

```
#找到所有可用docker版本列表
yum list docker-ce --showduplicates | sort -r
# 安装指定版本，用上面的版本号替换<VERSION_STRING>
sudo yum install docker-ce-<VERSION_STRING>.x86_64 docker-ce-cli-
<VERSION_STRING>.x86_64 containerd.io
#例如：
#yum install docker-ce-3:20.10.5-3.el7.x86_64 docker-ce-cli-3:20.10.5-
3.el7.x86_64 containerd.io
#注意加上 .x86_64 大版本号
```

#### 2、离线安装

```
- https://download.docker.com/linux/centos/7/x86_64/stable/Packages/

- rpm -ivh xxx.rpm
可以下载 tar
解压启动即可

- https://docs.docker.com/engine/install/binaries/#install-daemon-and-client-binaries-on-linux

```

### 5、启动服务

```
systemctl start docker
systemctl enable docker
```

### 6、镜像加速

```
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://mfs5bvup.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker

#以后docker下载直接从阿里云拉取相关镜像
```



### 7、可视化界面-Portainer
#### 1、什么是Portainer

[Portainer官网](https://documentation.portainer.io)

```
Portainer社区版2.0拥有超过50万的普通用户，是功能强大的开源工具集，可让您轻松地在Docker，
Swarm，Kubernetes和Azure ACI中构建和管理容器。 Portainer的工作原理是在易于使用的GUI后面隐藏
使管理容器变得困难的复杂性。通过消除用户使用CLI，编写YAML或理解清单的需求，Portainer使部署
应用程序和解决问题变得如此简单，任何人都可以做到。 Portainer开发团队在这里为您的Docker之旅提
供帮助；
```



#### 2、安装

```
 # 服务端部署
docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v
/var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data
portainer/portainer-ce
# 访问 9000 端口即可
# agent端部署
docker run -d -p 9001:9001 --name portainer_agent --restart=always -v
/var/run/docker.sock:/var/run/docker.sock -v
/var/lib/docker/volumes:/var/lib/docker/volumes portainer/agent

```



# 二、docker命令

## 1、常用命令

[官方基础命令文档](https://docs.docker.com/engine/reference/commandline/docker/)

| 命令      | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| attach    | 绑定到运行中容器的 标准输入, 输出,以及错误流（这样似乎也能进入容器内容，但 是一定小心，他们操作的就是控制台，控制台的退出命令会生效，比如 redis,nginx...） |
| build     | 从一个 Dockerfile 文件构建镜像                               |
| commit    | 把容器的改变 提交创建一个新的镜像                            |
| cp        | 容器和本地文件系统间 复制 文件/文件夹cp -rp[原文件或目录]　[目标文件或目录] －r  复制目录  \- p  保留文件属性 |
| create    | 创建新容器，但并不启动（注意与docker run 的区分）需要手动启动。start\stop |
| diff      | 检查容器里文件系统结构的更改【A：添加文件或目录 D：文件或者目录删除 C：文 件或者目录更改】 |
| events    | 获取服务器的实时事件                                         |
| exec      | 在运行时的容器内运行命令                                     |
| export    | 导出容器的文件系统为一个tar文件。commit是直接提交成镜像，export是导出成文 件方便传输 |
| history   | 显示镜像的历史                                               |
| images    | 列出所有镜像                                                 |
| import    | 导入tar的内容创建一个镜像，再导入进来的镜像直接启动不了容器。 /docker-entrypoint.sh nginx -g 'daemon o |
| info      | 显示系统信息                                                 |
| inspect   | 获取docker对象的底层信息                                     |
| kill      | 杀死一个或者多个容器                                         |
| load      | 从 tar 文件加载镜像  docker load -i xxx.tar                  |
| login     | 登录Docker registry                                          |
| logout    | 退出Docker registry                                          |
| logs      | 获取容器日志；容器以前在前台控制台能输出的所有内容，都可以看到 |
| pause     | 暂停一个或者多个容器                                         |
| port      | 列出容器的端口映射                                           |
| ps        | 列出所有容器    docker ps -a  列出包括已停止的所有容器       |
| pull      | 从registry下载一个image 或者repository                       |
| push      | 给registry推送一个image或者repository                        |
| rename    | 重命名一个容器                                               |
| restart   | 重启一个或者多个容器                                         |
| rm        | 移除一个或者多个容器                                         |
| rmi       | 移除一个或者多个镜像                                         |
| run       | 创建并启动容器                                               |
| save      | 把一个或者多个镜像保存为tar文件 docker save -o  [容器名称]:[容器标签] > xxx.tar |
| search    | 去docker hub寻找镜像                                         |
| start     | 启动一个或者多个容器                                         |
| stop      | 停止一个或者多个容器                                         |
| tag       | 给源镜像创建一个新的标签，变成新的镜像                       |
| unpause   | pause的反操作                                                |
| update    | 更新一个或者多个docker容器配置                               |
| version   | Show the Docker version information                          |
| container | 管理容器                                                     |
| image     | 管理镜像                                                     |
| network   | 管理网络                                                     |
| volume    | 管理卷                                                       |
| stats     | 显示容器资源的实时使用状态                                   |
| top       | 显示正在运行容器的进程                                       |



```
# 根据正在运行的容器制作出相关的镜像：反向 

  根据镜像启动一个容器：正向

# docker pull redis == docker pull redis:latest（最新版）

# 镜像是怎么做成的。基础环境+软件
redis的完整镜像应该是： linux系统+redis软件
alpine：超级经典版的linux 5mb；+ redis = 29.0mb
没有alpine3的：就是centos基本版

# 以后自己选择下载镜像的时候尽量使用
alpine： slim：
docker rmi -f $(docker images -aq) #删除全部镜像
docker image prune #移除游离镜像 dangling：游离镜像（没有镜像名字的，注意看结果可能删不掉）
docker tag 原镜像:标签 新镜像名:标签 #重命名
docker create [OPTIONS] IMAGE [COMMAND] [ARG...]
docker create [设置项] 镜像名 [启动] [启动参数...]
docker create redis: 按照redis:latest镜像启动一个容器
docker kill是强制kill -9（直接拔电源）；
docker stop可以允许优雅停机(当前正在运行中的程序处理完所有事情后再停止)

docker create --name myredis -p 6379（主机的端口）:6379（容器的端口） redis
-p port1:port2
port1是必须唯一的，那个是没关系的。

docker run --name myredis2 -p 6379:6379 -p 8888:6379 redis ：默认是前台启动的，一
般加上-d 让他后台悄悄启动, 虚拟机的很多端口绑定容器的一个端口是允许的
docker run -d == docker create + docker start

#启动了nginx；一个容器。docker 容器里面安装了nginx，要对nginx的所有修改都要进容器
#进容器：
docker attach 绑定的是控制台. 可能导致容器停止。不要用这个
docker exec -it -u 0:0 --privileged mynginx4 /bin/bash： 0用户，以特权方式进入容器
docker container inspect 容器名 = docker inspect 容器名
docker inspect image/network/volume ....

# 一般运行中的容器会常年修改，我们要使用最终的新镜像
docker commit -a hzhero -m "first commit" mynginx4 mynginx:v4


#把新的镜像放到远程docker hub，方便后来在其他机器下载
#---------export操作容器/import-------------------
docker export导出的文件被import导入以后变成镜像，并不能直接启动容器，需要知道之前的启动命令
（docker ps --no-trunc），然后再用下面启动。
docker run -d -P mynginx:v6 /docker-entrypoint.sh nginx -g 'daemon off;'
或者docker image inspect 看之前的镜像，把 之前镜像的 Entrypoint的所有和 Cmd的连接起来就
能得到启动命令


#----save/load--操作镜像--
docker save -o busybox.tar busybox:latest 把busybox镜像保存成tar文件
docker load -i busybox.tar 把压缩包里面的内容直接导成镜像


#----------
镜像为什么能长久运行
镜像启动一定得有一个阻塞的进程，一直干活，在这里代理。
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
docker run --name myredis2 -p 6379:6379 -p 8888:6379 redis
镜像启动以后做镜像里面默认规定的活。
docker run -it busybox; 交互模式进入当前镜像启动的容器
---------


#----产生镜像-----
1、基于已经存在的容器，提取成镜像
2、人家给了我tar包，导入成镜像
3、做出镜像
-1)、准备一个文件Dockerfile
FROM busybox
CMD ping baidu.com
-2)、编写Dockerfile
-3)、构建镜像
docker build -t mybusy66:v6 -f Dockerfile .


#---做redis的镜像---
FROM alpine（基础镜像）
//下载安装包
//解压
//准备配置文件
CMD redis-server redis.conf


#----------
build 是根据一个Dockerfile构建出镜像
commit 是正在运行中的容器提交成一个镜像

# 容器的状态
Created（新建）、Up（运行中）、Pause（暂停）、Exited（退出）
docker run的立即启动，docker create得稍后自己启动

#推送镜像
注册docker hub并登录
可以创建一个仓库，选为public
docker push hzhero/mynginx:tagname
docker hub一个完整镜像的全路径是
docker.io/library/redis:alpine3.13 我们的 docker.io/hzhero/mynginx:tagname
docker images的时候镜像缩略了全名 默认官方镜像没有docker.io/library/
docker.io/ rediscommander / redis-commander:latest
docker.io/hzhero/mynginx:v4 我的镜像的全称
登录远程docker仓库
当前会话登录以后 docker login 。所有的东西都会push到这个人的仓库
docker push hzhero/mynginx:tagname
上面命令的完整版 docker push docker.io/hzhero/mynginx:v4
怎么知道是否登录了 cat ~/.docker/config.json 有没有 auth的值，没有就是没有登录
docker hub太慢了，用阿里云的镜像仓库，或者以后的habor仓库

sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/hzh/mynginx:
[镜像版sudo docker push registry.cn-hangzhou.aliyuncs.com/hzh/mynginx:[镜
像版本号]
仓库网址/名称空间(hzh/hzhero)/仓库名:版本号
```

![image-20220112104333411](../../assets/docker.assets/image-20220112104333411.png)

![image-20220112102831242](../../assets/docker.assets/image-20220112102831242.png)

## 2、典型命令

### 1、docker run

常用关键参数 OPTIONS 说明：

```
-d: 后台运行容器，并返回容器ID；
-i: 以交互模式运行容器，通常与 -t 同时使用；
-P: 随机端口映射，容器内部端口随机映射到主机的端口
-p:指定端口映射，格式为：主机(宿主)端口:容器端口
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用
--name="nginx-lb":为容器指定一个名称；
--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；
--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；
-h "mars": 指定容器的hostname；
-e username="ritchie": 设置环境变量；
--env-file=[]: 从指定文件读入环境变量；
--cpuset="0-2" or --cpuset="0,1,2": 绑定容器到指定CPU运行；
-m :设置容器使用内存最大值；
--net="bridge": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
--link=[]: 添加链接到另一个容器；
--expose=[]: 开放一个端口或一组端口；
--restart , 指定重启策略，可以写--restart=awlays 总是故障重启
--volume , -v: 绑定一个卷。一般格式 主机文件或文件夹:虚拟机文件或文件夹
```

#### 0、如何使用Docker部署组件
#### 1、部署Nginx

```
# 注意 外部的/etc/nginx/html和/etc/nginx/conf下面的内容必须存在，否则挂载会覆盖
vim /etc/nginx/conf/default.conf
server {
    # 80端口是http正常访问的接口
    listen       80;
    client_max_body_size 200m;

    location / {
            if (!-e $request_filename) {
                rewrite ^(.*)$ /index.html?s=$1 last;
                break;
            }
        root   /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
        index  index.html index.htm;
     }
}


docker run --name nginx-app -p 80:80 -v /etc/nginx/html:/usr/share/nginx/html:ro -v /etc/nginx/conf:/etc/nginx/conf.d -d nginx
```



#### 2、部署MySQL

```
# 5.7版本
docker run -p 3306:3306 --name mysql57-app \
-v /app/mysql/log:/var/log/mysql \
-v /app/mysql/data:/var/lib/mysql \
-v /app/mysql/conf:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql:5.7



#8.x版本,引入了 secure-file-priv 机制，磁盘挂载将没有权限读写data数据，所以需要将权限透传，
或者chmod -R 777 /app/mysql/data
# --privileged 特权容器，容器内使用真正的root用户
docker run -p 3306:3306 --name mysql8-app \
-v /app/mysql/conf:/etc/mysql/conf.d \
-v /app/mysql/log:/var/log/mysql \
-v /app/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
--privileged \
-d mysql

```



#### 3、部署ElasticSearch

```
#准备文件和文件夹，并chmod -R 777 xxx
#配置文件内容，参照
https://www.elastic.co/guide/en/elasticsearch/reference/7.5/node.name.html 搜索相
关配置
# 考虑为什么挂载使用esconfig ...
docker run --name=elasticsearch -p 9200:9200 -p 9300:9300 \
-e "discovery.type=single-node" \
-e ES_JAVA_OPTS="-Xms300m -Xmx300m" \
-v /app/es/data:/usr/share/elasticsearch/data \
-v /app/es/plugins:/usr/shrae/elasticsearch/plugins \
-v esconfig:/usr/share/elasticsearch/config \
-d elasticsearch:7.12.0

```



#### 4、部署Tomcat

```
# 考虑，如果我们每次 -v 都是指定磁盘路径，是不是很麻烦？
docker run --name tomcat-app -p 8080:8080 \
-v tomcatconf:/usr/local/tomcat/conf \
-v tomcatwebapp:/usr/local/tomcat/webapps \
-d tomcat:jdk8-openjdk-slim-buster
```



#### 5、部署Redis

```
# 提前准备好redis.conf文件，创建好相应的文件夹。目录为/app/redis/redis.conf，内容为：
port 6379
appendonly yes
#更多配置参照 https://raw.githubusercontent.com/redis/redis/6.0/redis.conf
docker run -p 6379:6379 --name redis \
-v /app/redis/redis.conf:/etc/redis/redis.conf \
-v /app/redis/data:/data \
-d redis:6.2.1-alpine3.13 \
redis-server /etc/redis/redis.conf --appendonly yes
```



#### 6、重启策略

```
no，默认策略，在容器退出时不重启容器
on-failure，在容器非正常退出时（退出状态非0），才会重启容器
on-failure:3，在容器非正常退出时重启容器，最多重启3次
always，在容器退出时总是重启容器
unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容
器
```



## 2、docker exec

一般用来与正在运行的容器进行交互，在容器内执行命令

```
$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
```

- OPTIONS

  | Name, shorthand                                              | Default | Description                                          |
  | ------------------------------------------------------------ | ------- | ---------------------------------------------------- |
  | `--detach` , `-d`                                            |         | Detached mode: run command in the background         |
  | `--detach-keys`                                              |         | Override the key sequence for detaching a container  |
  | [`--env`](https://docs.docker.com/engine/reference/commandline/exec/#env) , [`-e`](https://docs.docker.com/engine/reference/commandline/exec/#env) |         | Set environment variables                            |
  | `--env-file`                                                 |         | Read in a file of environment variables              |
  | `--interactive` , `-i`                                       |         | Keep STDIN open even if not attached                 |
  | `--privileged`                                               |         | Give extended privileges to the command              |
  | `--tty` , `-t`                                               |         | Allocate a pseudo-TTY                                |
  | `--user` , `-u`                                              |         | Username or UID (format: `<name|uid>[:<group|gid>]`) |
  | [`--workdir`](https://docs.docker.com/engine/reference/commandline/exec/#workdir) , [`-w`](https://docs.docker.com/engine/reference/commandline/exec/#workdir) |         | Working directory inside the container               |

- 常用事例：

1、直接操作

```
docker exec -it alpine sh
```

2、进入容器后的指定目录

```
docker exec -it -w /root alpine pwd
```



## 3、docker build

docker build 命令从 Dockerfile 和“上下文”构建 Docker 镜像。构建的上下文是位于指定 PATH 或 URL 中的一组文件。构建过程可以引用上下文中的任何文件。例如，您的构建可以使用 COPY 指令在上下文中引用文件。

```
docker build [OPTIONS] PATH | URL | -
```

- 常用事例：

1、本地目录下构建

- 通过文件MyDockerfile构建镜像名字为：myImageName

```
docker build -t myImageName -f MyDockerfile .
```

2、通过URL构建

- 这将克隆 GitHub 存储库并将克隆的存储库用作上下文。存储库根目录下的 Dockerfile 用作 Dockerfile。可以使用 git:// 或 git@ 方案指定任意 Git 存储库

```
docker build github.com/creack/docker-firefox
```



## 4、docker push

上传镜像到仓库

```
docker push [OPTIONS] NAME[:TAG]
```

- OPTIONS

  | Name, shorthand                                              | Default | Description                                 |
  | ------------------------------------------------------------ | ------- | ------------------------------------------- |
  | [`--all-tags`](https://docs.docker.com/engine/reference/commandline/push/#all-tags) , [`-a`](https://docs.docker.com/engine/reference/commandline/push/#all-tags) |         | Push all tags of an image to the repository |
  | `--disable-content-trust`                                    | `true`  | Skip image signing                          |
  | `--quiet` , `-q`                                             |         | Suppress verbose output                     |

- 常用事例

  1、上传本地镜像myapache:v1到指定镜像仓库中。

```
docker push myapache:v1 registry-host:5000/myadmin/myapache:v1
```

​	   2、 也可以通过tag命令预先指定镜像名称和版本号，优势是多版本推送

```
# 1、本地预先打标签
docker image tag myimage registry-host:5000/myname/myimage:latest
docker image tag myimage registry-host:5000/myname/myimage:v1.0.1
docker image tag myimage registry-host:5000/myname/myimage:v1.0
docker image tag myimage registry-host:5000/myname/myimage:v1

# 2、查看
docker image ls

REPOSITORY                          TAG        IMAGE ID       CREATED      SIZE
myimage                             latest     6d5fcfe5ff17   2 hours ago  1.22MB
registry-host:5000/myname/myimage   latest     6d5fcfe5ff17   2 hours ago  1.22MB
registry-host:5000/myname/myimage   v1         6d5fcfe5ff17   2 hours ago  1.22MB
registry-host:5000/myname/myimage   v1.0       6d5fcfe5ff17   2 hours ago  1.22MB
registry-host:5000/myname/myimage   v1.0.1     6d5fcfe5ff17   2 hours ago  1.22MB

# 3、通过-a 或 --all-tags 推送
docker image push --all-tags registry-host:5000/myname/myimage
```



# 三、网络和存储原理

问题： 

- 容器： 某个软件完整的运行环境；包含了一个小型的linux系统 

- 宿主机里面同时4个nginx； 一个nginx运行时完整环境有20MB？

  -  4个nginx 合起来占用多少的磁盘空间 
  - 80？一定会很大....

  

-  docker装的和宿主机的优缺点： 

  - 优点：docker的移植性、便捷性高于在宿主机部署、进程隔离、很方便的资源限制 

  - 缺点：docker虚拟化技术，损失不到3%的性能。 

    

  - docker？原生物理机自己造docker这种东西。 

  - 镜像（Image）：固定不变的。一个镜像可以启动很多容器 

  - 容器（Container）：文件系统可能logs经常变化的，一个镜像可以启动很多容器。 

  - docker在底层使用自己的存储驱动。来组件文件内容 storage drivers。docker 基于 AUFS（联合文件系统）

## 1、Docker存储
### 1、镜像如何存储
#### 0、自己探索

FROM busybox 

CMD ping baidu.com 

截取的nginx的分层

```
nginx这个镜像怎么存的
使用：docker image inspect nginx
```

![image-20220112105627092](../../assets/docker.assets/image-20220112105627092.png)

指示了镜像怎么存的

- LowerDir ：底层目录; diff(只是存储不同)；包含小型linux和装好的软件

  ```
  /var/lib/docker/overlay2/67b3802c6bdb5bcdbcccbbe7aed20faa7227d584ab37668a03ff6952e
  631f7f2/diff：用户文件；
  /var/lib/docker/overlay2/f56920fac9c356227079df41c8f4b056118c210bf4c50bd9bb077bdb4
  c7524b4/diff： nginx的启动命令放在这里
  /var/lib/docker/overlay2/0e569a134838b8c2040339c4fdb1f3868a7118dd7f4907b40468f5fe6
  0f055e5/diff： nginx的配置文件在这里
  /var/lib/docker/overlay2/2b51c82933078e19d78b74c248dec38164b90d80c1b42f0fdb1424953
  207166e/diff: 小linux系统
  ```

- 倒着看

  - 小linux系统（FROM apline） + Dockerfile的每一个命令可能都引起了系统的修改，所以和git 一样，只记录变化

  - 我们进入到这个镜像启动的容器，容器的文件系统就是镜像的；

  - docker ps -s；可以看到这个容器真正用到的文件大小

  - 容器会自己建立层；如果想要改东西，把改的内容复制到容器层即可 docker inspect container

    ```
    "LowerDir":
    "/var/lib/docker/overlay2/41e4fa41a2ad1dca9616d4c8254a04c4d9d6a3d462
    c862f1e9a0562de2384dbcinit/diff:/var/lib/docker/overlay2/e3b8bdbb0cfbe5450696c470994b3f99e
    8a7942078e2639a788027529c6278f7/diff:/var/lib/docker/overlay2/67b380
    2c6bdb5bcdbcccbbe7aed20faa7227d584ab37668a03ff6952e631f7f2/diff:/var
    /lib/docker/overlay2/f56920fac9c356227079df41c8f4b056118c210bf4c50bd
    9bb077bdb4c7524b4/diff:/var/lib/docker/overlay2/0e569a134838b8c20403
    39c4fdb1f3868a7118dd7f4907b40468f5fe60f055e5/diff:/var/lib/docker/ov
    erlay2/2b51c82933078e19d78b74c248dec38164b90d80c1b42f0fdb14249532071
    66e/diff",
    
    "MergedDir":
    "/var/lib/docker/overlay2/41e4fa41a2ad1dca9616d4c8254a04c4d9d6a3d462
    c862f1e9a0562de2384dbc/merged",
    
    "UpperDir": （镜像的上层可以感知变
    化）"/var/lib/docker/overlay2/41e4fa41a2ad1dca9616d4c8254a04c4d9d6a3d
    462c862f1e9a0562de2384dbc/diff",【容器的修改后的文件，保存再宿主机哪里呀。
    容器删除后，那些容器目录还存在吗？一定不再】
    
    "WorkDir":
    "/var/lib/docker/overlay2/41e4fa41a2ad1dca9616d4c8254a04c4d9d6a3d462
    c862f1e9a0562de2384dbc/work"
    ```

- MergedDir ：合并目录；容器最终的完整工作目录全内容都在合并层；数据卷在容器层产生；所 有的增删改都在容器层；

  - ![image-20220112110750671](../../assets/docker.assets/image-20220112110750671.png)

- UpperDir ：上层目录；

- WorkDir ：工作目录（临时层），pid；

  ```
  LowerDir（底层）\UpperDir（）\MergedDir\WorkDir(临时东西)
  ```

- docker底层的 storage driver完成了以上的目录组织结果；

#### 1、images and layers

Docker映像由一系列层组成。 每层代表图像的Dockerfile中的一条指令。 除最后一层外的每一层都是只 读的。 如以下Dockerfile： 

- Dockerfile文件里面几句话，镜像就有几层

  ```
  FROM ubuntu:15.04
  COPY . /app
  RUN make /app
  CMD python /app/app.py
  # 每一个指令都可能会引起镜像改变，这些改变类似git的方式逐层叠加。
  ```

  ```
  该Dockerfile包含四个命令，每个命令创建一个层。
  FROM语句从ubuntu：15.04映像创建一个图层开始。
  COPY命令从Docker客户端的当前目录添加一些文件。
  RUN命令使用make命令构建您的应用程序。
  最后，最后一层指定要在容器中运行的命令。
  每一层只是与上一层不同的一组。 这些层彼此堆叠。
  创建新容器时，可以在基础层之上添加一个新的可写层。 该层通常称为“容器层”。 对运行中
  的容器所做的所有更改（例如写入新文件，修改现有文件和删除文件）都将写入此薄可写容
  器层。
  ```

  ![image-20220112112018808](../../assets/docker.assets/image-20220112112018808.png)

#### 2、Container and layers

> - 容器和镜像之间的主要区别是可写顶层。
> - 在容器中添加新数据或修改现有数据的所有写操作都存储在此可写层中。
> - 删除容器后，可写层也会被删除。 基础图像保持不变。 因为每个容器都有其自己的可写容
>   器层，并且所有更改都存储在该容器层中，所以多个容器可以共享对同一基础映像的访问，
>   但具有自己的数据状态。




#### 3、磁盘容量预估

> docker ps -s 
>
> size：用于每个容器的可写层的数据量（在磁盘上）。
>
>  virtual size：容器使用的用于只读图像数据的数据量加上容器的可写图层大小。 多个容器可以共享部分或全部只读图像数据。 从同一图像开始的两个容器共享100％的只读数据，而具有不同图像的两个容器（具有相同的层）共享这些公共 层。 因此，不能只对虚拟大小进行总计。这高估了总磁盘使用量，可能是一笔不小的数目。

#### 4、镜像如何挑选

```
busybox：是一个集成了一百多个最常用Linux命令和工具的软件。linux工具里的瑞士军刀

alpine：Alpine操作系统是一个面向安全的轻型Linux发行版经典最小镜像，基于busybox，功能比
Busybox完善。

slim：docker hub中有些镜像有slim标识，都是瘦身了的镜像。也要优先选择
无论是制作镜像还是下载镜像，优先选择alpine类型.

```



#### 5、Copy On Write

> - 写时复制是一种共享和复制文件的策略，可最大程度地提高效率。
> -  如果文件或目录位于映像的较低层中，而另一层（包括可写层）需要对其进行读取访问，则它仅使用现有文件。
> -  另一层第一次需要修改文件时（在构建映像或运行容器时），将文件复制到该层并进行修改。 这 样可以将I / O和每个后续层的大小最小化。

### 2、容器如何挂载

![image-20220112114951928](../../assets/docker.assets/image-20220112114951928.png)

```
每一个容器里面的内容，支持三种挂载方式：
1）、docker自动在外部创建文件夹自动挂载容器内部指定的文件夹内容【Dockerfile VOLUME指令的作
用】
2）、自己在外部创建文件夹，手动挂载
3）、可以把数据挂载到内存中。
--mount 挂载到 linux宿主机，手动挂载（不用了）
-v 可以自动挂载，到linux主机或者docker自动管理的这一部分区域
```







| 命令                   | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| Volumes(卷)            | 存储在主机文件系统的一部分中，该文件系统由Docker管理（在Linux上是“ / var /<br/>lib / docker / volumes /”）。 非Docker进程不应修改文件系统的这一部分。 卷是在Docker中持久存<br/>储数据的最佳方法。 |
| Bind mounts(绑定挂载)  | 可以在任何地方 存储在主机系统上。 它们甚至可能是重要的系统文件或<br/>目录。 Docker主机或Docker容器上的非Docker进程可以随时对其进行修改。 |
| tmpfs mounts(临时挂载) | 仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统 |



#### 1、volume（卷）

- 匿名卷使用

  ```
  docker run -dP -v :/etc/nginx nginx
  #docker将创建出匿名卷，并保存容器/etc/nginx下面的内容
  # -v 宿主机:容器里的目录
  ```

  

- 具名卷使用

  ```
  docker run -dP -v nginx:/etc/nginx nginx
  #docker将创建出名为nginx的卷，并保存容器/etc/nginx下面的内容
  ```

  > 如果将空卷装入存在文件或目录的容器中的目录中，则容器中的内容（复制）到该卷中。
  >
  > 如果启动一个容器并指定一个尚不存在的卷，则会创建一个空卷。

  ```
  -v 宿主机绝对路径:Docker容器内部绝对路径：叫挂载；这个有空挂载问题
  -v 不以/开头的路径:Docker容器内部绝对路径：叫绑定（docker会自动管理，docker不会把他当前目
  录，而把它当前卷）
  
  以上用哪个比较好？？？？？？
  如果自己开发测试，用 -v 绝对路径的方式
  如果是生产环境建议用卷
  除非特殊 /bin/docker 需要挂载主机路径的则操作 绝对路径挂载
  ```

  > nginx--Docker /usr/share/nginx/html 
  >
  > nginx测试html挂载几种不同情况： 
  >
  > 	- 不挂载 效果：访问默认欢迎页
  > 	-  -v /root/html:/usr/share/nginx/html 效果：访问forbidden 
  > 	- -v html:/usr/share/nginx/html:ro 效果：访问默认欢迎页
  > 	- -v /usr/share/nginx/html 效果：匿名卷 （什么都不写也不要加冒号，直接写容器内的目录） 
  >  - 原因： 
  >    	- -v html:/usr/share/nginx/html； docker inspect 容器的时候； docker自动管理的方式
  >
  > ```
  > # -v不以绝对路径方式；
  > ### 1、先在docker底层创建一个你指定名字的卷（具名卷） html
  > ### 2、把这个卷和容器内部目录绑定
  > ### 3、容器启动以后，目录里面的内容就在卷里面存着；
  > #####-v nginxhtml:/usr/share/nginx/html 也可以以下操作
  > 
  > 
  > ## 1、docker run -d -P -v nginxhtml:/usr/share/nginx/html --
  > name=nginx777 nginx
  > ## 1、 docker create volume nginxhtml 如果给卷里面就行修改，容器内部的也就改
  > 了。
  > ## 2、 docker ps 
  > [root@localhost _data]# docker ps
  > CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                     NAMES
  > 23eafedea375   nginx     "/docker-entrypoint.…"   5 minutes ago   Up 5 minutes   0.0.0.0:49153->80/tcp, :::49153->80/tcp   nginx777
  > 
  > 
  > ## 3、 docker inspect 23eafedea375
  > 可以看到
  > 
  > "Mounts": [
  > {
  > "Type": "volume", //这是个卷
  > "Name": "nginxhtml", //名字是html
  > "Source": "/var/lib/docker/volumes/nginxhtml/_data", //宿主
  > 机的目录。容器里面的哪两个文件都在
  > "Destination": "/usr/share/nginx/html", //容器内部
  > "Driver": "local",
  > "Mode": "z",
  > "RW": true, //读写模式
  > "Propagation": ""
  > }
  > ]
  > 
  > ## 4、如果给卷里面就行修改，容器内部的也就改
  > 了
  > 
  > #卷：就是为了保存数据
  > docker volume #可以对docker自己管理的卷目录进行操作；
  > /var/lib/docker/volumes(卷的根目录)
  > ```
  >
  > 

#### 2、bind mount

> 如果将绑定安装或非空卷安装到存在某些文件或目录的容器中的目录中，则这些文件或目录会被 安装遮盖，就像您将文件保存到Linux主机上的/ mnt中一样，然后 将USB驱动器安装到/ mnt中。 在卸载USB驱动器之前，/ mnt的内容将被USB驱动器的内容遮盖。 被遮盖的文件不会被删除或更 改，但是在安装绑定安装或卷时将无法访问。 总结：外部目录覆盖内部容器目录内容，但不是修改。所以谨慎，外部空文件夹挂载方式也会导 致容器内部是空文件夹




- **bind mount和 volumes 的方式写法区别在于:**

  - **所有以/开始的都认为是 bind mount ，不以/开始的都认为是 volumes.**

```
docker run -dP -v /my/nginx:/etc/nginx:ro nginx

警惕bind mount 方式，文件挂载没有在外部准备好内容而导致的容器启动失败问题
```

```
# 一行命令启动nginx，并且配置文件和html页面。需要知道卷的位置才能改
docker run -d -P -v nginxconf:/etc/nginx/ -v nginxpage:/usr/share/nginx/html nginx
# 想要实现 docker run -d -P -v /root/nginxconf:/etc/nginx/ -v
/root/nginxhtml:/usr/share/nginx/html --name=nginx999 nginx


### 1、提前准备好东西 目录nginxconf，目录里面的配置we年都放里面，，再调用命令
### 2、docker cp nginxdemo:/etc/nginx /root/nginxconf #注意/的使用
### 3、docker run -d -P -v /root/nginxconf:/etc/nginx/ -v
/root/nginxhtml:/usr/share/nginx/html --name=nginx999 nginx

```



### 3、管理卷

```
docker volume create xxx：创建卷名
docker volume inspect xxx：查询卷详情
docker volume ls: 列出所有卷
docker volume prune: 移除无用卷
```



### 4、docker cp

cp的细节

```
docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- ：把容器里面的复制出来
docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH：把外部的复制进去
```

- SRC_PATH 指定为一个文件 

  - DEST_PATH 不存在：文件名为 DEST_PATH ，内容为SRC的内容 
  - DEST_PATH 不存在并且以 / 结尾：报错 
  - DEST_PATH 存在并且是文件：目标文件内容被替换为SRC_PATH的文件内容。 
  - DEST_PATH 存在并且是目录：文件复制到目录内，文件名为SRC_PATH指定的名字 

- SRC_PATH 指定为一个目录 

  - DEST_PATH 不存在： DEST_PATH 创建文件夹，复制源文件夹内的所有内容 

  - DEST_PATH 存在是文件：报错 

  - DEST_PATH 存在是目录 

    - SRC_PATH 不以 /. 结束：源文件夹复制到目标里面 

    - SRC_PATH 以 /. 结束：源文件夹里面的内容复制到目标里面 自动创建文件夹不会做递归。把父文件夹做好 

      

  [root@hzh ~]# docker cp index.html mynginx4:/usr/share/nginx/html 

  [root@hzh ~]# docker cp mynginx4:/etc/nginx/nginx.conf nginx.conf

## 2、Docker网络
### 1、端口映射

```
docker create -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name=hello-mysql mysql:5.7
```



### 2、容器互联

--link name:alias ，name连接容器的名称，alias连接的别名 

场景：我们无需暴露mysql的情况下，让web应用使用mysql；

```
docker run -d -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
docker run -d --link mysql01:mysql --name tomcat tomcat:7
docker exec -it tomcat bash
cat /etc/hosts
ping mysql
```



### 3、自定义网络
#### 1、默认网络原理

Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据 Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。 因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。

![image-20220112143319080](../../assets/docker.assets/image-20220112143319080.png)

Docker容器网络就很好的利用了Linux虚拟网络技术，在本地主机和容器内分别创建一个虚拟接口，并让 他们彼此联通（这样一对接口叫veth pair）；

Docker中的网络接口默认都是虚拟的接口。虚拟接口的优势就是转发效率极高（因为Linux是在内核中进行数据的复制来实现虚拟接口之间的数据转发，无需通过外部的网络设备交换），对于本地系统和容器 系统来说，虚拟接口跟一个正常的以太网卡相比并没有区别，只是他的速度快很多。

- 原理： 
  - 1、每一个安装了Docker的linux主机都有一个docker0的虚拟网卡。桥接网卡 
  - 2、每启动一个容器linux主机多了一个虚拟网卡。 
  - 3、docker run -d -P --name tomcat --net bridge tomcat:8

#### 2、网络模式

| 网络模式      | 配置                    | 说明                                                         |
| ------------- | ----------------------- | ------------------------------------------------------------ |
| bridge模式    | --net=bridge            | 默认值，在Docker网桥docker0上为容器创建新的网络 栈           |
| none模式      | --net=none              | 不配置网络，用户可以稍后进入容器，自行配置                   |
| container模式 | --net=container:name/id | 容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。 |
| host模式      | --net=host              | 容器和宿主机共享Network namespace                            |
| 用户自定义    | --net=mynet             | 用户自己使用network相关命令定义网络，创建容器的时候可以指定为自己定义的网络 |



#### 3、自建网络测试

```
#1、docker0网络的特点。，
    默认、域名访问不通、--link 域名通了，但是删了又不行

#2、可以让容器创建的时候使用自定义网络，用自定义
    1、自定义创建的默认default "bridge"
    2、自定义创建一个自定义网络
    docker network create --driver bridge --subnet 192.168.0.0/16 --gateway
    192.168.0.1 mynet
    所有东西实时维护好，直接域名ping通
    docker network connect [OPTIONS] NETWORK CONTAINER

#3、跨网络连接别人就用。把tomcat加入到mynet网络
    docker network connect mynet tomcat
    效果：
    1、自定义网络，默认都可以用主机名访问通
    2、跨网络连接别人就用 docker network connect mynet tomcat

#4、命令
    1、容器启动，指定容器ip。 docker run --ip 192.168.0.3 --net 自定义网络
    2、创建子网。docker network create --subnet 指定子网范围 --driver bridge 所有东西实时
    维护好，直接域名ping通
    3、docker compose 中的网络默认就是自定义网络方式。

docker run -d -P --network 自定义网络名(提前创建)
```



# 四、深入Dockerfile

Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。 (文件名无后缀)

基础的小linux系统。如：jdk

 一般而言，Dockerfile可以分为四部分 

- 基础镜像信息 

- 维护者信息 

- 镜像操作指令 

- 启动时执行指令

  | 指令        | 说明                                                         |
  | ----------- | ------------------------------------------------------------ |
  | FROM        | 指定基础镜像                                                 |
  | MAINTAINER  | 指定维护者信息，已经过时，可以使用LABEL maintainer=xxx 来代替 |
  | RUN         | 运行命令                                                     |
  | CMD         | 指定启动容器时默认的命令                                     |
  | ENTRYPOINT  | 指定镜像的默认入口.运行命令                                  |
  | EXPOSE      | 声明镜像内服务监听的端口                                     |
  | ENV         | 指定环境变量，可以在docker run的时候使用-e改变 ；会被固化到image的 config里面 |
  | ADD         | 复制指定的src路径下的内容到容器中的dest路径下，src可以为url会自动下载， 可以为tar文件，会自动解压 |
  | COPY        | 复制本地主机的src路径下的内容到镜像中的dest路径下，但不会自动解压等 |
  | LABEL       | 指定生成镜像的元数据标签信息                                 |
  | VOLUME      | 创建数据卷挂载点                                             |
  | USER        | 指定运行容器时的用户名或UID                                  |
  | WORKDIR     | 配置工作目录，为后续的RUN、CMD、ENTRYPOINT指令配置工作目录   |
  | ARG         | 指定镜像内使用的参数（如版本号信息等），可以在build的时候，使用--build-args改变 |
  | OBBUILD     | 配置当创建的镜像作为其他镜像的基础镜像时，所指定的创建操作指令 |
  | STOPSIGNAL  | 容器退出的信号值                                             |
  | HEALTHCHECK | 健康检查                                                     |
  | SHELL       | 指定使用shell时的默认shell类型                               |

  

## 1、FROM

FROM 指定基础镜像，最好挑一些apline，slim之类的基础小镜像. scratch镜像是一个空镜像，常用于多阶段构建 

如何确定我需要什么样的基础镜像？ 

- Java应用当然是java基础镜像（SpringBoot应用）或者Tomcat基础镜像（War应用） 
- JS模块化应用一般用nodejs基础镜像 
- 其他各种语言用自己的服务器或者基础环境镜像，如python、golang、java、php等

## 2、LABEL

标注镜像的一些说明信息。

```
LABEL multi.label1="value1" multi.label2="value2" other="value3"
LABEL multi.label1="value1" \
multi.label2="value2" \
other="value3"
```



## 3、RUN（构建过程打印）

- RUN指令在当前镜像层顶部的新层执行任何命令，并提交结果，生成新的镜像层。 

- 生成的提交映像将用于Dockerfile中的下一步。 分层运行RUN指令并生成提交符合Docker的核心概 念，就像源代码控制一样。 

- exec形式可以避免破坏shell字符串，并使用不包含指定shell可执行文件的基本映像运行RUN命令。 可以使用SHELL命令更改shell形式的默认shell。 在shell形式中，您可以使用\（反斜杠）将一条 RUN指令继续到下一行。

  > - RUN  ( shell 形式, /bin/sh -c 的方式运行，避免破坏shell字符串) 
  > - RUN ["executable", "param1", "param2"] ( exec 形式）

  ```
  RUN /bin/bash -c 'source $HOME/.bashrc; \
  echo $HOME'
  #上面等于下面这种写法
  RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'
  RUN ["/bin/bash", "-c", "echo hello"]
  ```

  ```
  # 测试案例
  FROM alpine
  LABEL maintainer=hzhero xx=aa
  ENV msg='hello atguigu itdachang'
  RUN echo $msg
  RUN ["echo","$msg"]
  RUN /bin/sh -c 'echo $msg'
  RUN ["/bin/sh","-c","echo $msg"]
  CMD sleep 10000
  #总结； 由于[]不是shell形式，所以不能输出变量信息，而是输出$msg。其他任何/bin/sh -c 的形式都
  可以输出变量信息
  ```

- 总结：什么是shell和exec形式

  ```
  1. shell 是 /bin/sh -c <command>的方式，
  2. exec ["/bin/sh","-c",command] 的方式== shell方式
  也就是exec 默认方式不会进行变量替换
  ```

  

## 4、CMD和ENTRYPOINT（都是只在运行时生效）

### 0、都可以作为容器启动入口

CMD 的三种写法： 

- CMD ["executable","param1","param2"] ( exec 方式, 首选方式) 
- CMD ["param1","param2"] (为ENTRYPOINT提供默认参数) 
- CMD command param1 param2 ( shell 形式) 

ENTRYPOINT 的两种写法： 

- ENTRYPOINT ["executable", "param1", "param2"] ( exec 方式, 首选方式) 
- ENTRYPOINT command param1 param2 (shell 形式)



```
# 一个示例
FROM alpine
LABEL maintainer=hzhero
CMD ["1111"]
CMD ["2222"]
ENTRYPOINT ["echo"]
#构建出如上镜像后测试
docker run xxxx：效果 echo 2222
```



### 1、只能有一个CMD

- Dockerfile中只能有一条CMD指令。 如果您列出多个CMD，则只有最后一个CMD才会生效。 
- CMD的主要目的是为执行中的容器提供默认值。 这些默认值可以包含可执行文件，也可以省略可 执行文件，在这种情况下，您还必须指定ENTRYPOINT指令。

### 2、CMD为ENTRYPOINT提供默认参数

如果使用CMD为ENTRYPOINT指令提供默认参数，则CMD和ENTRYPOINT指令均应使用JSON数组格 式指定。

### 3、组合最终效果

|                            | 无ENTRYPOINT                            | ENTRYPOINT exec_entry p1_entry | ENTRYPOINT [“exec_entry”, “p1_entry”]            |
| -------------------------- | --------------------------------------- | ------------------------------ | ------------------------------------------------ |
| 无CMD                      | 错误, 不允许的写 法 ；容器没有启动 命令 | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry                              |
| CMD [“exec_cmd”, “p1_cmd”] | exec_cmd p1_cmd                         | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry exec_cmd p1_cmd              |
| CMD [“p1_cmd”, “p2_cmd”]   | p1_cmd p2_cmd                           | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry p1_cmd p2_cmd                |
| CMD exec_cmd p1_cmd        | /bin/sh -c exec_cmd p1_cmd              | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry [/bin/sh -c exec_cmd p1_cmd] |
|                            |                                         | 此列总是以ENTRYPOINT为准       | 此列，ENTRYPOINT和CMD共同作用                    |



### 4、docker run 启动参数会覆盖CMD内容

```
# 一个示例
FROM alpine
LABEL maintainer=hzhero
CMD ["1111"]
ENTRYPOINT ["echo"]

#构建出如上镜像后测试
docker run xxxx：什么都不传则  echo 1111
docker run xxx arg1：传入arg1 则echo arg1
```



## 5、ARG和ENV（ENV会覆盖ARG）
### 1、ARG(构建参数，只能在构建时RUN打印，运行时CMD ENTRYPOINT打印不出来)

- ARG指令定义了一个变量，用户可以在构建时使用--build-arg  =  传递，docker build命令会将其传递
  给构建器。 
- --build-arg 指定参数会覆盖Dockerfile 中指定的同名参数
- 如果用户指定了 未在Dockerfile中定义的构建参数 ，则构建会输出 警告 。 
- ARG只在构建期有效，运行期无效
- 不建议使用构建时变量来传递诸如github密钥，用户凭据等机密。因为构建时变量值使用docker 
  history是可见的。
- ARG变量定义从Dockerfile中定义的行开始生效。 
- 使用ENV指令定义的环境变量始终会覆盖同名的ARG指令。

### 2、ENV(只能在运行期生效)

- 在构建阶段中所有后续指令的环境中使用，并且在许多情况下也可以内联替换。 

- 引号和反斜杠可用于在值中包含空格。

- ENV 可以使用key  value的写法，但是这种不建议使用了，后续版本可能会删除

  ```
  ENV MY_MSG hello
  ENV MY_NAME="John Doe"
  ENV MY_DOG=Rex\ The\ Dog
  ENV MY_CAT=fluffy
  #多行写法如下
  ENV MY_NAME="John Doe" MY_DOG=Rex\ The\ Dog \
  MY_CAT=fluffy
  ```

- docker run --env 可以修改这些值 

- 容器运行时ENV值可以生效

- ENV在image阶段就会被解析并持久化（docker inspect image查看），参照下面示例。

  ```
  FROM alpine
  ENV arg=1111111
  ENV runcmd=$arg
  RUN echo $runcmd
  CMD echo $runcmd
  #ENV的固化问题： 改变arg，会不会改变 echo的值，会改变哪些值，如何修改这些值?
  docker build --no-cache -t demo:test  -f dockerfile1 . 
  [root@localhost hzh]# docker run --env arg=222 bda9843ece19
  1111111
  ```

  

### 3、综合测试示例

```
FROM alpine
ARG arg1=22222
ENV arg2=1111111
ENV arg3=3333333
ENV runcmd=$arg1
ENV runcmd2=$arg3
RUN echo $arg1 $arg2 $runcmd $runcmd2
CMD echo $arg1 $arg2 $runcmd $runcmd2

[root@localhost hzh]# docker build --no-cache -t demo:test  -f dockerfile3 .
Sending build context to Docker daemon   5.12kB
Step 1/8 : FROM alpine
 ---> c059bfaa849c
Step 2/8 : ARG arg1=22222
 ---> Running in f268afb15919
Removing intermediate container f268afb15919
 ---> b9cb5acbcf8a
Step 3/8 : ENV arg2=1111111
 ---> Running in 02b53262b28a
Removing intermediate container 02b53262b28a
 ---> a6374e1227eb
Step 4/8 : ENV arg3=3333333
 ---> Running in 4429a64647d2
Removing intermediate container 4429a64647d2
 ---> b2867fe9fcd8
Step 5/8 : ENV runcmd=$arg1
 ---> Running in 6258b73903b5
Removing intermediate container 6258b73903b5
 ---> 08a713f21542
Step 6/8 : ENV runcmd2=$arg3
 ---> Running in d8b4496877bc
Removing intermediate container d8b4496877bc
 ---> 10681685a6c6
Step 7/8 : RUN echo $arg1 $arg2 $runcmd $runcmd2
 ---> Running in d9f073299461
22222 1111111 22222 3333333
Removing intermediate container d9f073299461
 ---> 479679fbcd8f
Step 8/8 : CMD echo $arg1 $arg2 $runcmd $runcmd2
 ---> Running in a789f06f3d71
Removing intermediate container a789f06f3d71
 ---> 0d9f14f33ef1
Successfully built 0d9f14f33ef1
Successfully tagged demo:test
[root@localhost hzh]# docker run -e arg1="444",arg3="555" 0d9f14f33ef1
444,arg3=555 1111111 22222 3333333
[root@localhost hzh]# docker run -e arg1="444" -e arg3="555" 0d9f14f33ef1
444 1111111 22222 3333333


#arg1 被覆盖为ENV 所以被打印了
#arg3先被持久化 所以$runcmd2打印为3333333

```



## 6、ADD和COPY

### 1、COPY

COPY的两种写法

```
COPY [--chown=<user>:<group>] <src>... <dest>
COPY [--chown=<user>:<group>] ["<src>",... "<dest>"]
```

- --chown功能仅在用于构建Linux容器的Dockerfiles上受支持，而在Windows容器上不起作用 
- COPY指令从 src 复制新文件或目录，并将它们添加到容器的文件系统中，路径为 dest 。
- 可以指定多个 src 资源，但是文件和目录的路径将被解释为相对于构建上下文的源。 
- 每个 src 都可以包含通配符，并且匹配将使用Go的filepath.Match规则进行。

```
COPY hom* /mydir/ #当前上下文，以home开始的所有资源
COPY hom?.txt /mydir/ # ?匹配单个字符
COPY test.txt relativeDir/ # 目标路径如果设置为相对路径，则相对与 WORKDIR 开始
# 把 “test.txt” 添加到 <WORKDIR>/relativeDir/
COPY test.txt /absoluteDir/ #也可以使用绝对路径，复制到容器指定位置
#所有复制的新文件都是uid(0)/gid(0)的用户，可以使用--chown改变
COPY --chown=55:mygroup files* /somedir/
COPY --chown=bin files* /somedir/
COPY --chown=1 files* /somedir/
COPY --chown=10:11 files* /somedir/

```



### 2、ADD

同COPY用法，不过 ADD拥有自动下载远程文件和解压的功能。 

注意：

- src 路径必须在构建的上下文中； 不能使用 ../something /something 这种方式，因为docker 构建的第一步是将上下文目录（和子目录）发送到docker守护程序。 
- 如果 src 是URL，并且 dest 不以斜杠结尾，则从URL下载文件并将其复制到 dest 。 
  - 如果 dest 以斜杠结尾，将自动推断出url的名字（保留最后一部分），保存到 dest 
- 如果 src 是目录，则将复制目录的整个内容，包括文件系统元数据。



## 7、WORKDIR和VOLUME
### 1、WORKDIR

- WORKDIR指令为Dockerfile中跟随它的所有 RUN，CMD，ENTRYPOINT，COPY，ADD 指令设置工作目 录。 如果WORKDIR不存在，即使以后的Dockerfile指令中未使用它也将被创建。 

- WORKDIR指令可在Dockerfile中多次使用。 如果提供了相对路径，则它将相对于上一个WORKDIR指 令的路径。 例如：

  ```
  WORKDIR /a
  WORKDIR b
  WORKDIR c
  RUN pwd
  #结果 /a/b/c
  ```

- 也可以用到环境变量

  ```
  ENV DIRPATH=/path
  WORKDIR $DIRPATH/$DIRNAME
  RUN pwd
  #结果 /path/$DIRNAME
  ```

  

### 2、VOLUME

作用：把容器的某些文件夹映射到主机外部 

写法：

```
VOLUME ["/var/log/"] #可以是JSON数组
VOLUME /var/log #可以直接写
VOLUME /var/log /var/db #可以空格分割多个
```

注意： 用 VOLUME 声明了卷，那么在这一行之后对于卷内容的修改会被丢弃，所以， 一定在volume声明之前修改内容 ；

```
FROM alpine

RUN mkdir /hello &&mkdir /app
RUN echo 1111 > /hello/a.txt
RUN echo 2222 > /app/b.txt
# 挂载 容器的指定文件夹，如果不存在就创建
# 指定了VOLUME，即使启动容器没有指定 -v 参数，我们也会自动进行匿名卷挂载
# 容器内的/hello /app文件夹，在使用镜像启动容器的时候，自动给宿主机挂载

#VOLUME挂载出去的东西，容器改变也不会最终commit的时候生效
#只是为了方便容器启动后，宿主机和容器直接方便文件传输或者同步修改
VOLUME ["/hello", "/app"]
#VOLUME 指定的挂载目录

# 这两句话没有生效
RUN echo 6666 >>  /hello/a.txt
RUN echo 8888 >> /app/b.txt

CMD ping baidu.com


[root@localhost hzh]# docker build --no-cache -t demo:test  -f dockerfile4 .
Sending build context to Docker daemon  6.656kB
Step 1/8 : FROM alpine
 ---> c059bfaa849c
Step 2/8 : RUN mkdir /hello &&mkdir /app
 ---> Running in caca1ee42d10
Removing intermediate container caca1ee42d10
 ---> 144f38a938d5
Step 3/8 : RUN echo 1111 > /hello/a.txt
 ---> Running in 1296256552cd
Removing intermediate container 1296256552cd
 ---> 07cf4f85ada9
Step 4/8 : RUN echo 2222 > /app/b.txt
 ---> Running in c22bb65909f8
Removing intermediate container c22bb65909f8
 ---> fbee52567277
Step 5/8 : VOLUME ["/hello", "/app"]
 ---> Running in c43f6ed5b9fa
Removing intermediate container c43f6ed5b9fa
 ---> d1a87b02d53c
Step 6/8 : RUN echo 6666 >>  /hello/a.txt
 ---> Running in 8ef8a7702887
Removing intermediate container 8ef8a7702887
 ---> 41b731518e9b
Step 7/8 : RUN echo 8888 >> /app/b.txt
 ---> Running in e2778101beb6
Removing intermediate container e2778101beb6
 ---> 006843ded13f
Step 8/8 : CMD ping baidu.com
 ---> Running in 0ab295c77c66
Removing intermediate container 0ab295c77c66
 ---> c84867879973
Successfully built c84867879973
Successfully tagged demo:test

[root@localhost hzh]# docker run -d -P  c84867879973
17b209864395fd7419a0bb22370cc4839d85d115db9a1f1c7a5947236dca548b
[root@localhost hzh]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS     NAMES
17b209864395   c84867879973   "/bin/sh -c 'ping ba…"   3 seconds ago   Up 2 seconds             intelligent_lichterman

[root@localhost hzh]# docker inspect 17b209864395
[
    {
        "Id": "17b209864395fd7419a0bb22370cc4839d85d115db9a1f1c7a5947236dca548b",
        "Created": "2022-01-12T10:11:28.557803298Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
            "ping baidu.com"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 24882,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2022-01-12T10:11:28.959047886Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:c84867879973ca0bb31470be36cd43b9c7191c9bfb22fcbad923eb7cfa9ff16b",
        "ResolvConfPath": "/var/lib/docker/containers/17b209864395fd7419a0bb22370cc4839d85d115db9a1f1c7a5947236dca548b/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/17b209864395fd7419a0bb22370cc4839d85d115db9a1f1c7a5947236dca548b/hostname",
        "HostsPath": "/var/lib/docker/containers/17b209864395fd7419a0bb22370cc4839d85d115db9a1f1c7a5947236dca548b/hosts",
        "LogPath": "/var/lib/docker/containers/17b209864395fd7419a0bb22370cc4839d85d115db9a1f1c7a5947236dca548b/17b209864395fd7419a0bb22370cc4839d85d115db9a1f1c7a5947236dca548b-json.log",
        "Name": "/intelligent_lichterman",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": true,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/4f563f3f33e7de6d94a8297c9e952819bcc29b2e911e089512c351c3d71a8edb-init/diff:/var/lib/docker/overlay2/fc498dec72595aaaaa87c596f8320732a801f23b9f8f3c584c84bcf377ce2949/diff:/var/lib/docker/overlay2/6bb5823617cec58f587704068adac52dbfd924cc25b13a0bb1213cc7779653b7/diff:/var/lib/docker/overlay2/cb6538f91de4af5307be08d8f4d51611075e24e1c86a51c6640e40d91f955db9/diff:/var/lib/docker/overlay2/1d72b306ec40f2bbcc0555957984ff6d6b08be172075c4a35498a6794ec9fb1d/diff",
                "MergedDir": "/var/lib/docker/overlay2/4f563f3f33e7de6d94a8297c9e952819bcc29b2e911e089512c351c3d71a8edb/merged",
                "UpperDir": "/var/lib/docker/overlay2/4f563f3f33e7de6d94a8297c9e952819bcc29b2e911e089512c351c3d71a8edb/diff",
                "WorkDir": "/var/lib/docker/overlay2/4f563f3f33e7de6d94a8297c9e952819bcc29b2e911e089512c351c3d71a8edb/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [
            {
                "Type": "volume",
                "Name": "8fb68385ed20365b8f99b72948a3b6499d2e22a3c2618d55da11be0ae7ef7eda",
                "Source": "/var/lib/docker/volumes/8fb68385ed20365b8f99b72948a3b6499d2e22a3c2618d55da11be0ae7ef7eda/_data",
                "Destination": "/hello",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            },
            {
                "Type": "volume",
                "Name": "a2623f9b6b97c28063099f378bfd374ee495ac6e183ae10169966f3e8bb6f4c9",
                "Source": "/var/lib/docker/volumes/a2623f9b6b97c28063099f378bfd374ee495ac6e183ae10169966f3e8bb6f4c9/_data",
                "Destination": "/app",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
        "Config": {
            "Hostname": "17b209864395",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "ping baidu.com"
            ],
            "Image": "c84867879973",
            "Volumes": {
                "/app": {},
                "/hello": {}
            },
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {}
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "3afb2f26675442701adb5ee23dfb1e1649d0227c3ee1edc689266cfd2455a944",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/3afb2f266754",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "581beda59106ff764e60cf08ab088a080f2bfefee8d348e785d1eebb9d2dc012",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "d9bc9bf896664b970195e03de603c983fb9983dcf6b987cede491d338b41d193",
                    "EndpointID": "581beda59106ff764e60cf08ab088a080f2bfefee8d348e785d1eebb9d2dc012",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]

[root@localhost hzh]# cd /var/lib/docker/volumes/8fb68385ed20365b8f99b72948a3b6499d2e22a3c2618d55da11be0ae7ef7eda/_data
[root@localhost _data]# ll
总用量 4
-rw-r--r--. 1 root root 5 1月  12 18:06 a.txt

# 可以看到声明之后确实没有生效
[root@localhost _data]# cat a.txt
1111
[root@localhost _data]# vim a.txt
[root@localhost _data]# cat a.txt
1111
2222
[root@localhost _data]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS     NAMES
17b209864395   c84867879973   "/bin/sh -c 'ping ba…"   About a minute ago   Up About a minute             intelligent_lichterman

[root@localhost _data]# docker exec -it 17b209864395 /bin/sh
/ # cd /hello

/hello # ls
a.txt
/hello # cat a.txt
1111
2222

```



## 8、USER

写法：

```
USER <user>[:<group>]
USER <UID>[:<GID>]
```

- USER指令设置运行映像时要使用的用户名（或UID）以及可选的用户组（或GID），以及Dockerfile 中USER后面所有RUN，CMD和ENTRYPOINT指令。

## 9、EXPOSE

- EXPOSE指令通知Docker容器在运行时在指定的网络端口上进行侦听。 可以指定端口是侦听TCP还 是UDP，如果未指定协议，则默认值为TCP。 

- EXPOSE指令实际上不会发布端口。 它充当构建映像的人员和运行容器的人员之间的一种文档，即 有关打算发布哪些端口的信息。 要在运行容器时实际发布端口，请在docker run上使用-p标志发布 并映射一个或多个端口，或使用-P标志发布所有公开的端口并将其映射到高阶端口。

  ```
  EXPOSE <port> [<port>/<protocol>...]
  EXPOSE [80,443]
  EXPOSE 80/tcp
  EXPOSE 80/udp
  ```

  

## 10、multi-stage builds

### 1、使用

[多阶段构建官方文档](https://docs.docker.com/develop/develop-images/multistage-build/ )

解决：如何让一个镜像变得更小; 多阶段构建的典型示例

```
### 我们如何打包一个Java镜像
FROM maven
WORKDIR /app
COPY . .
RUN mvn clean package
COPY /app/target/*.jar /app/app.jar
ENTRYPOINT java -jar app.jar
## 这样的镜像有多大？
## 我们最小做到多大？？
```



### 2、生产示例

```
#以下所有前提 保证Dockerfile和项目在同一个文件夹
# 第一阶段：环境构建; 用这个也可以
FROM maven:3.5.0-jdk-8-alpine AS builder
WORKDIR /app
ADD ./ /app
RUN mvn clean package -Dmaven.test.skip=true
# 第二阶段，最小运行时环境，只需要jre；第二阶段并不会有第一阶段哪些没用的层
#基础镜像没有 jmap； jdk springboot-actutor（jdk）
FROM openjdk:8-jre-alpine
LABEL maintainer="534096094@qq.com"
# 从上一个阶段复制内容
COPY --from=builder /app/target/*.jar /app.jar
# 修改时区
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo
'Asia/Shanghai' >/etc/timezone && touch /app.jar
ENV JAVA_OPTS=""
ENV PARAMS=""
# 运行jar包
ENTRYPOINT [ "sh", "-c", "java -Djava.security.egd=file:/dev/./urandom
$JAVA_OPTS -jar /app.jar $PARAMS" ]
```

```yaml
    <!--为了加速下载需要在pom文件中复制如下 -->
    <repositories>
        <repository>
            <id>aliyun</id>
            <name>Nexus Snapshot Repository</name>
            <url>https://maven.aliyun.com/repository/public</url>
            <layout>default</layout>
            <releases>
                <enabled>true</enabled>
            </releases>
            <!--snapshots默认是关闭的,需要开启 -->
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
    </repositories>
    <pluginRepositories>
    <pluginRepository>
    <id>aliyun</id>
    <name>Nexus Snapshot Repository</name>
    <url>https://maven.aliyun.com/repository/public</url>
    <layout>default</layout>
    <releases>
        <enabled>true</enabled>
    </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
    </pluginRepositories>

```

```
######小细节
RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo
'Asia/Shanghai' >/etc/timezone
或者
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo
'Asia/Shanghai' >/etc/timezone
可以让镜像时间同步。
## 容器同步系统时间 CST（China Shanghai Timezone）
-v /etc/localtime:/etc/localtime:ro
#已经不同步的如何同步？
docker cp /etc/localtime 容器id:/etc/
```

docker build --build-arg url="git address" -t demo:test . ：自动拉代码并构建镜像

```
FROM maven:3.6.1-jdk-8-alpine AS buildapp
#第二阶段，把克隆到的项目源码拿过来
# COPY --from=gitclone * /app/
WORKDIR /app
COPY pom.xml .
COPY src .
RUN mvn clean package -Dmaven.test.skip=true
# /app 下面有 target
RUN pwd && ls -l
RUN cp /app/target/*.jar /app.jar
RUN ls -l
### 以上第一阶段结束，我们得到了一个 app.jar
## 只要一个JRE
# FROM openjdk:8-jre-alpine
FROM openjdk:8u282-slim
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo
'Asia/Shanghai' >/etc/timezone
LABEL maintainer="534096094@qq.com"
# 把上一个阶段的东西复制过来
COPY --from=buildapp /app.jar /app.jar
# docker run -e JAVA_OPTS="-Xmx512m -Xms33 -" -e PARAMS="--spring.profiles=dev -
-server.port=8080" -jar /app/app.jar
# 启动java的命令
ENV JAVA_OPTS=""
ENV PARAMS=""
ENTRYPOINT [ "sh", "-c", "java -Djava.security.egd=file:/dev/./urandom
$JAVA_OPTS -jar /app.jar $PARAMS" ]
```



## 11、images瘦身实践

- 最小的基础镜像

- 合并RUN环节的所有指令，少生成一些层 

- RUN期间可能安装其他程序会生成临时缓存，要自行删除。如：

  ```
  # 开发期间，逐层验证正确的
  RUN xxx
  RUN xxx
  RUN aaa \
  aaa \
  vvv \
  
  
  
  
  #生产环境
  RUN apt-get update && apt-get install -y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion \
  && rm -rf /var/lib/apt/lists/*
  ```

- 使用.dockerignore 文件，排除上下文中无需参与构建的资源 

- 使用多阶段构建 

- 合理使用构建缓存加速构建。[--no-cache]

## 12、springboot java 最终写法

```
FROM openjdk:8-jre-alpine
LABEL maintainer="534096094@qq.com"
COPY target/*.jar /app.jar
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo
'Asia/Shanghai' >/etc/timezone && touch /app.jar
ENV JAVA_OPTS=""
ENV PARAMS=""
ENTRYPOINT [ "sh", "-c", "java -Djava.security.egd=file:/dev/./urandom
$JAVA_OPTS -jar /app.jar $PARAMS" ]
# 运行命令 docker run -e JAVA_OPTS="-Xmx512m -Xms33 -" -e PARAMS="--
spring.profiles=dev --server.port=8080" -jar /app/app.jar
```



# 五、熟悉docker-compose

https://docs.docker.com/compose/install/ 

场景： 一个复杂的应用，不是启动一个容器就能完成的 

app = nginx + web + mysql +redis 

以后只要启动app，创建app。都得run 4个，保证网络畅通+挂载ok 

docker-compose 

不懂yaml？？？？？？？？？？？？ 

application.yaml 



可以写一个yaml文件。指定所有需要启动的内容。docker-compose up/down

## 1、基础

安装

```
sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/dockercompose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```



## 2、yaml语法

```yaml
{
  "name": "itdachang",
  "url": "http://www.itdachang.com",
  "page": 88,
  "address": {
    "street": "宏福科技园",
    "city": "北京市昌平区",
    "country": "中国"
  },
  "links": [
    {
      "name": "Google",
      "url": "http://www.google.com"
    },
    {
      "name": "Baidu",
      "url": "http://www.baidu.com"
    }
  ]
}
```



## 3、compose语法

app == wordpress （个人博客） web ---- mysql（存储层）



## 4、compose示例

hello-world

```
 mkdir composetest
```

创建app.py 其他.,..,



- 编写compose文件[compose.yaml] 

- compose文件名 docker-compose.yml, docker-compose.yaml, compose.yml, compose.yaml

  ```
  version: "3.9" #指定版本号;查看文档https://docs.docker.com/compose/compose-file/
  services: #所有需要启动的服务
    web: #第一个服务的名字
      build: #docker build -t xxx -f Dockerfile .
        dockerfile: Dockerfile
        context: .
      image: 'hello:py'
      ports: #指定启动容器暴露的端口
        - "5000:5000"
    redis: #第二个服务的名字
      image: "redis:alpine"
  # mysqlserver: #第三个服务
  
  
  #怎么执行的
  Creating network "composetest_default" with the default driver
  Building web
  Sending build context to Docker daemon 5.632kB
  
  Step 1/10 : FROM python:3.7-alpine
  。。。。。。
  Step 10/10 : CMD ["flask", "run"]
  ---> Running in 01e36491132c
  Removing intermediate container 01e36491132c
  ---> 47d09826ac6f
  Successfully built 47d09826ac6f
  Successfully tagged hello:py
  ======web镜像名 hello:py===
  
  
  WARNING: Image for service web was built because it did not already exist. To
  rebuild this image you must use `docker-compose build` or `docker-compose up --
  build`.
  Pulling redis (redis:alpine)...
  .......
  Status: Downloaded newer image for redis:alpine
  ##下载成功
  
  
  Creating composetest_redis_1 ... done
  Creating composetest_web_1 ... done
  Attaching to composetest_web_1, composetest_redis_1
  redis_1 | 1:C 15 Apr 2021 13:55:27.693 # oO0OoO0OoO0Oo Redis is starting
  oO0OoO0OoO0Oo
  redis_1 | 1:C 15 Apr 2021 13:55:27.693 # Redis version=6.2.1, bits=64,
  commit=00000000, modified=0, pid=1, just started
  
  redis_1 | 1:C 15 Apr 2021 13:55:27.693 # Warning: no config file specified,
  using the default config. In order to specify a config file use redis-server
  /path/to/redis.conf
  redis_1 | 1:M 15 Apr 2021 13:55:27.694 * monotonic clock: POSIX clock_gettime
  redis_1 | 1:M 15 Apr 2021 13:55:27.695 * Running mode=standalone, port=6379.
  redis_1 | 1:M 15 Apr 2021 13:55:27.695 # WARNING: The TCP backlog setting of
  511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower
  value of 128.
  redis_1 | 1:M 15 Apr 2021 13:55:27.695 # Server initialized
  redis_1 | 1:M 15 Apr 2021 13:55:27.695 # WARNING overcommit_memory is set to 0!
  Background save may fail under low memory condition. To fix this issue add
  'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the
  command 'sysctl vm.overcommit_memory=1' for this to take effect.
  redis_1 | 1:M 15 Apr 2021 13:55:27.695 * Ready to accept connections
  web_1 | * Serving Flask app "app.py"
  web_1 | * Environment: production
  web_1 | WARNING: This is a development server. Do not use it in a
  production deployment.
  web_1 | Use a production WSGI server instead.
  web_1 | * Debug mode: off
  web_1 | * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
  
  
  #因为compose创建了自定义网络，大家都能通
  ```

  - 启动命令：  docker-compose up -d （一句话后台启动这个）

  ```
  version: "3.9" #指定版本号;查看文档https://docs.docker.com/compose/compose-file/
  services: #所有需要启动的服务
    web: #第一个服务的名字
      build: #docker build -t xxx -f Dockerfile .
        dockerfile: Dockerfile
        context: .
      image: 'hello:py'
      ports: #指定启动容器暴露的端口
        - "5000:5000"
    redis: #第二个服务的名字
      image: "redis:alpine"
    mysql:
      image: "mysql"
  # 其他volumes,networks等
  # compose+docker swarm == 集群部署
  ```

  ```
  version: "3.7"
  services:
    app:
      image: node:12-alpine
      command: sh -c "yarn install && yarn run dev"
      ports:
        - 3000:3000
        working_dir: /app
        volumes:
          - ./:/app
        environment:
          MYSQL_HOST: mysql
          MYSQL_USER: root
          MYSQL_PASSWORD: secret
          MYSQL_DB: todos
        networks:
          - hello
          - world
        deploy: #安装docker swarm
          replicas: 6 #指定副本：处于不同的服务器（负载均衡+高可用）
          
      mysql: #可以代表一个容器，ping 服务名 mysql 可以访问
        image: mysql:5.7 #负载均衡下，数据一致怎么做？？？主从同步，读写分离
        volumes:
          - todo-mysql-data:/var/lib/mysql
        environment:
          MYSQL_ROOT_PASSWORD: secret
          MYSQL_DATABASE: todos
        networks: #这个服务加入那个自定义网络
          - hello
        deploy: #安装docker swarm
          replicas: 6 #指定副本：处于不同的服务器（负载均衡+高可用）
      redis:
        image: redis
        networks:
          - world
  volumes:
    todo-mysql-data:
  networks:
    hello:
    world:
  ```

  

# 六、docker swarm



两句： 

- docker swarm init （创建一个master 节点） 
  - 控制台打印 
  - docker swarm join --token SWMTKN-1-1i0biktih9tfn7mrj6asn27em4vydg8pp00u930nrycpgct1ww7ecs32nl5f5y8qx6e5lp4f064 10.120.82.4:2377 
- 其他和本机（master）能互通的机器 把上面的命令运行，加入集群 
  -  docker swarm join --token SWMTKN-1-1i0biktih9tfn7mrj6asn27em4vydg8pp00u930nrycpgct1ww7ecs32nl5f5y8qx6e5lp4f064 10.120.82.4:2377

 



k8s怎么解决： helm把整个应用的部署打成应用包，helm install mysql（主从）
